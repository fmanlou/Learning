<center>AVL</center>

### 平衡二叉树

AVL树是一种自平衡二叉查找树。在AVL树中任何节点的左右子树的高度最大差1。

### 性能分析
二叉树的查找性能是和树的高度是线性相关的，树的高度越低，查找的时间复杂度就越低。例如AVL树的高度是lg(n)，所以AVL树查找的时间复杂度也保持在lg(n)的水平。

### 插入操作
1. 当插入某个节点时，被插入的节点的高度没有发生变化，此时树的平衡性没有被破坏，因此不需要进行任何操作。
<table  rules=none   cellspacing=0  frame=void><tr>
<td   align=center><img src=1.1.png border=0></td>
<td   align=center><img src=1.2.png border=0></td>
</tr></table>
如上图所示，当插入b节点到a节点时，a节点高度没有发生改变，并且其他所有的节点的高度都没有发生变化，所以树仍然是平衡的。
2. 当插入某个节点时，导致被插入的节点高度发生了改变，此时插入的节点的父节点高度加1，同时会继续影响到上一个父节点。此时分为两种情况：
2.1 当改变某个父节点的高度时，导致其失去了平衡性，此时，需要对该节点进行恢复平衡的操作。由于恢复平衡操作会使该子树的整体高度减1，因此在该节点以上的所有其他父节点高度均未发生改变，同时此次的插入操作结束。
<table  rules=none   cellspacing=0  frame=void><tr>
<td   align=center><img src=2.1.1.png border=0></td>
<td   align=center><img src=2.1.2.png border=0></td>
<td   align=center><img src=2.1.3.png border=0></td>
</tr></table>
2.2 当所有的节点的平衡性都没有被破坏时，此时插入节点的所有父节点高度加1，直到根节点，完成此次插入操作。
<table  rules=none   cellspacing=0  frame=void><tr>
<td   align=center><img src=2.2.1.png border=0></td>
<td   align=center><img src=2.2.2.png border=0></td>
</tr></table>

#### 恢复平衡
当某个节点失去平衡时，必定是因为左右子树的高度差为2。
1. 假设该节点的左子树的高度比右子树的高度高。右子树的高度为和，此时左子树的高度为h+2。 
<table  rules=none   cellspacing=0  frame=void><tr>
<td   align=center><img src=3.1.png border=0></td>
</tr></table>
当插入的节点在C子树中时，可以分析出
$$
H(A) = h, H(B) = h, H(C) = h, H(D) = h - 1
$$
或者当插入的节点在D子树中时，可以分析出
$$
H(A) = h, H(B) = h, H(C) = h - 1, H(D) = h
$$
可以看出，在恢复平衡的过程中，A、B、C、D四个子树的高度不会发生任何变化，只有a、b、c节点的高度会发生改变（在这种情况下c节点的高度也没有发生改变）。此时
$$
H(a) = h + 1, H(b) = h + 2
$$
同时可以知道在插入节点之前，该树的高度h + 2，即H(a) = h + 2，在恢复平衡之后该树的高度任为h + 2，即H(b) = h + 2，所以在恢复平衡之后，b以上的所有父节点或者其他节点高度不会发生任何变化，此时整棵保持平衡的状态。

由此可以看出，所谓的恢复平衡的操作就是使不平衡的节点所在的子树高度减1，具体操作就是从a、b、c三个节点中选取中间值作为根节点，上图选取b作为中间根节点，将比b小的c节点作为左节点，比b大的a作为右节点，然后将A、B、C、D按照大小顺序依次连接在c节点和a节点上，从图中也可以直观的发现四层的树经过平衡之后变为了三层。

2. 
<table  rules=none   cellspacing=0  frame=void><tr>
<td   align=center><img src=3.2.png border=0></td>
</tr></table>
同样当插入节点到C子树的时候并且c节点是b的右节点，同样分析过程如上，将c作为根节点，对节点进行重新排列。

当b节点在a右边的时候同样还有两种情况，但是分析过程和以上情况是一样的，在此不做重复描述。

### 删除操作

当删除某个节点时，首先先寻找最接近该节点的值来代替该节点，要么选择左子树中的最大值来代替该节点，要么选择右子树中的最小值来代替该节点。但是因为将该节点移动至被删除的节点后，该节点的父节点高度以及平衡可能会受到影响，因此需要对每一个父节点高度进行更新，并且对平衡性进行检验，如果高度没有发生变化，则删除操作完成，如果高度有改变，则检查平衡性，若平衡性没有被破坏，则继续向上更新父节点的高度。



### 红黑树
红黑树通过对颜色巧妙的控制将树的高度维持在2lg(n)的水平，同时降低了删除和插入的时间复杂度，所以尽管红黑树的查找性能少略低于AVL树，但是如果结合删除、插入操作来看，红黑树的整体性能可能在AVL树之上，所以很多程序里面使用的是红黑树的数据结构，比如在linux内核中的进程管理使用的便是红黑树的数据结构。